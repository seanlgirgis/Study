**Project: Capital-One-CodeSignal-Prep-2026**  
**Sprint: 150.Lead-Data-Engineer-CodeSignal-Sprint**  
**Session: Day 1 — Phase A.1.1 → A.1.2 Traversal Patterns**  
**Artifact: Neighbor Comparison Pattern – Problem Specs & Intensive Test Cases**

### Pattern Focus: Neighbor Comparison (arr[i] vs arr[i-1])

This is one of the simplest yet most frequently appearing sub-patterns in array traversal problems at Capital One/CodeSignal level:

- You walk the array once (usually left-to-right).
- At each position `i ≥ 1`, you directly compare the current element `arr[i]` with the previous one `arr[i-1]`.
- You use that single comparison to decide something: count streaks, detect changes, group consecutive equals, find local peaks/valleys, calculate differences, etc.
- Often combined with a running counter, flag, or result append.

Very common in easy Q1/Q2 and as building blocks inside medium/hard problems.

### Practice Problem – Clean Test-Style Version

**Problem: Consecutive Increasing Groups**

Given a list of integers `nums`, return a list of strings where each string describes a maximal consecutive increasing group in the array.

For each group of **consecutive elements where each element is strictly greater than the previous one**, format it as:  
`"start→end (length)"`  
where `start` and `end` are the first and last values in that increasing run.

- If a number is not part of any increasing sequence longer than 1 (i.e., equal or decreasing), treat it as a group of length 1: just str(num)
- Single-element groups should just be the number as string
- The output list should have one entry per maximal group, in order of appearance

**Example 1:**  
Input: `nums = [1, 3, 5, 4, 2, 6, 8, 9, 7]`  
Output: `["1→5 (3)", "4", "2→9 (3)", "7"]`  
Explanation:  
- 1 < 3 < 5 → "1→5 (3)"  
- 5 > 4 → single "4"  
- 4 > 2 → single starts new, but 2 < 6 < 8 < 9 → "2→9 (3)"  
- 9 > 7 → single "7"

**Example 2:**  
Input: `nums = [10, 10, 10]`  
Output: `["10", "10", "10"]`  
(No strictly increasing pairs)

**Example 3:**  
Input: `nums = [5]`  
Output: `["5"]`

**Example 4:**  
Input: `[]`  
Output: `[]`

**Example 5:**  
Input: `[7, 8, 9, 10, 11]`  
Output: `["7→11 (5)"]`  
(One long strictly increasing run)

**Constraints:**  
- `0 ≤ len(nums) ≤ 10⁴`  
- `-10⁹ ≤ nums[i] ≤ 10⁹`  (wide range – no bucketing tricks)

**Your task:**  
Implement in the class below using neighbor comparison (compare `nums[i]` with `nums[i-1]` in a single pass).

```python
from typing import List


class Solution:
    def consecutiveIncreasingGroups(self, nums: List[int]) -> List[str]:
        """
        Returns a list of strings describing maximal strictly increasing consecutive groups.
        """
        # Your code here
        pass
```

### Instructions (simulate real test)
- Time goal: **under 10–12 minutes**
- Single pass only — use neighbor comparison (`nums[i] > nums[i-1]`)
- No sorting, no extra data structures beyond O(1) variables + the output list
- Handle empty list, single element, all equal, all increasing, all decreasing, mixed
- Use clean Python: type hints, early returns, clear variable names

### Intensive Test Cases (ready for copy-paste)

```python
from typing import List, Tuple

test_cases: List[Tuple[List[int], List[str]]] = [
    # Provided examples
    ([1, 3, 5, 4, 2, 6, 8, 9, 7], ["1→5 (3)", "4", "2→9 (3)", "7"]),
    ([10, 10, 10], ["10", "10", "10"]),
    ([5], ["5"]),
    ([], []),
    ([7, 8, 9, 10, 11], ["7→11 (5)"]),

    # Edge & trivial
    ([], []),
    ([42], ["42"]),
    ([1, 1], ["1", "1"]),
    ([9, 8, 7, 6], ["9", "8", "7", "6"]),           # strictly decreasing
    ([1, 2], ["1→2 (2)"]),

    # Long runs
    (list(range(1, 1001)), ["1→1000 (1000)"]),       # max increasing
    (list(range(1000, 0, -1)), [str(i) for i in range(1000, 0, -1)]),  # max decreasing

    # Alternating & plateaus
    ([1, 3, 2, 4, 3, 5, 4], ["1→3 (2)", "2→4 (2)", "3→5 (2)", "4"]),
    ([5, 5, 6, 6, 7, 8, 8], ["5", "5→6 (2)", "6→8 (3)", "8"]),
    ([1, 2, 2, 3, 4, 4, 5], ["1→2 (2)", "2→5 (4)"]),

    # Negative numbers & zero
    ([-5, -3, -1, 0, 2, 1], ["-5→2 (5)", "1"]),
    ([0, -1, -2, -3], ["0", "-1", "-2", "-3"]),

    # Mixed large/small
    ([100, 200, 150, -100, 300, 400, 350], ["100→200 (2)", "150", "-100→400 (4)", "350"]),
]
```

### Next Steps in Sprint
- Implement using a single loop + neighbor check (`if i > 0 and nums[i] > nums[i-1]`)
- Track current group start index or start value
- When streak breaks → format previous group and start new one
- Commit pattern name in filename: `solutions/2026-02-14-session-01/consecutive_increasing_groups.py`
- After solving: time yourself, run all test cases, log in decisions.md: "Neighbor comparison – clean O(n) single pass, handled negatives & large range"
- If fast & clean (< 10 min), move to next A.1 pattern or combine with prefix sums tomorrow

Ready to code it?  
Or want a 2-line pseudocode skeleton first (no full solution)?



**Project: Capital-One-CodeSignal-Prep-2026**  
**Sprint: 150.Lead-Data-Engineer-CodeSignal-Sprint**  
**Session: Day 1 — Phase A.1.2 Traversal Patterns**  
**Artifact: LeetCode Mapping for Current Drills**

The problem we just worked on — **Days Until Warmer** (given daily temperatures, return days to wait for a strictly warmer day) — is exactly:

**LeetCode 739. Daily Temperatures**

- Title: Daily Temperatures
- Difficulty: Medium
- Direct match: The description, examples, constraints (n ≤ 10⁴, temps 0–100), and output format are identical to what you were given.
- Classic patterns taught: monotonic stack (most common solution), reverse traversal (what we drilled), or even brute force for partial credit.

The neighbor comparison pattern problem I just gave you ("Consecutive Increasing Groups") does **not** have a 1:1 LeetCode equivalent with the exact output format ("start→end (length)"), but it is very close in spirit to several problems that heavily rely on comparing arr[i] with arr[i-1]:

Closest LeetCode analogs (all use neighbor comparison in core logic):
- **LeetCode 674. Longest Continuous Increasing Subsequence**  
  → Finds the length of the longest strictly increasing consecutive subarray (single integer answer)
- **LeetCode 443. String Compression**  
  → Groups consecutive equal characters and compresses (very similar grouping logic)
- **LeetCode 283. Move Zeroes**  
  → Uses neighbor swaps/comparisons in-place
- **LeetCode 26. Remove Duplicates from Sorted Array**  
  → Compares arr[i] == arr[i-1] to skip duplicates
- **LeetCode 121. Best Time to Buy and Sell Stock**  
  → Compares prices[i] with previous min

So in short:

| Problem we just did                  | LeetCode Number          | Notes                                      |
|--------------------------------------|--------------------------|--------------------------------------------|
| Days Until Warmer                    | **739**                  | Exact match – reverse traversal drill      |
| Consecutive Increasing Groups        | No direct # (but closest: **674**) | Custom format, but same core neighbor pattern |

If you want the next drill to be a pure LeetCode-tagged Capital One favorite using neighbor comparison, we can jump to one of:
- 674 (easy warmup continuation)
- 26 / 283 (in-place modification style)
- Or combine with prefix sums tomorrow (e.g., 560 or 53)

Which direction feels right for the rest of Day 1 / early Day 2?  
- Stick with neighbor comparison → do 674 or 26 next?  
- Move to prefix/suffix sums (A.1.2 / A.1.3 in roadmap)?  
- Or want me to pull a fresh Capital One-reported problem from recent candidate reports?