**Project: 150.Lead-Data-Engineer-CodeSignal-Sprint**  
**Session: 2026-02-15 – Sliding Window focus day**  
**Phase alignment: Phase B – Bread-and-Butter Tier (Two Pointers + Sliding Window)**

Great — since you've already handled LeetCode 2043 (Simple Bank System), and you're feeling good about basic two-pointer + min-length window patterns (209), let's double down on sliding window variants today.

Sliding window problems appear frequently in CodeSignal GCA-style assessments (Q2 or Q4), and Capital One reports often mention substring/subarray constraint problems. Strengthening this family now will give you fast, confident solves under time pressure.

### Suggested progression for today (Sliding Window ladder)

Pick 2–4 problems depending on how much time/energy you have. Aim to solve + clean + test each in 12–20 minutes.

| Order | Problem                                      | Difficulty | Core Variation                          | Why valuable for Capital One/CodeSignal | Estimated solve time (target) |
|-------|----------------------------------------------|------------|-----------------------------------------|------------------------------------------|-------------------------------|
| 1     | LeetCode 3. Longest Substring Without Repeating Characters | Medium     | Variable window + set / dict for chars  | Classic, very frequent, clean code test  | < 12 min                      |
| 2     | LeetCode 424. Longest Repeating Character Replacement | Medium     | Variable window + counter + max freq    | At-most-k changes → generalization       | 12–18 min                     |
| 3     | LeetCode 567. Permutation in String          | Medium     | Fixed-size window + counter comparison  | Anagram / permutation in stream          | 10–15 min                     |
| 4     | LeetCode 76. Minimum Window Substring        | Hard       | Variable window + required counter      | Hardest classic — Q4 differentiator      | 18–25 min (if time)           |
| Bonus | LeetCode 1004. Max Consecutive Ones III      | Medium     | Binary version (at-most-k flips)        | Quick win if you want momentum           | < 12 min                      |

### Recommended plan for the next 60–90 minutes

1. **Start with #1 or #2** — pick whichever feels fresher  
   → 3 is very clean and builds confidence  
   → 424 is a nice step-up from 209 (similar shrink logic but with frequency tracking)

2. Solve → write clean typed version with docstring  
3. Add 4–6 strong test cases (empty, single char, all same, no solution, etc.)  
4. Time yourself loosely (don't stress the stopwatch yet — focus on clean thinking)  
5. Paste your solution here when done → I'll review for style, edge cases, optimizations  
6. If we finish 2–3 quickly → we can do a short 25–30 min mini-mock with 2 window problems + 1 easy array/hash problem

### Quick mental templates to have ready

**Longest without repeating chars (3)**

```python
left = 0
seen = {}           # char → last index
max_len = 0

for right, char in enumerate(s):
    if char in seen and seen[char] >= left:
        left = seen[char] + 1
    seen[char] = right
    max_len = max(max_len, right - left + 1)
```

**Longest repeating with k replacements (424)**

```python
left = 0
count = defaultdict(int)
max_freq = 0
max_len = 0

for right, char in enumerate(s):
    count[char] += 1
    max_freq = max(max_freq, count[char])
    if right - left + 1 > max_freq + k:
        count[s[left]] -= 1
        left += 1
    max_len = max(max_len, right - left + 1)
```

**Minimum window substring (76)** — only attempt if you're feeling strong today

Which one do you want to start with right now?  
(or suggest a different window variant if you have one in mind)

Once you drop your solution I'll review fast and we keep moving.