# Databases (SQL vs NoSQL vs NewSQL)
### The English Version

---

## What is a Database and Why are there 50 kinds?

**The Problem:**
There is no "One Ring to Rule Them All."
*   If you optimize for **Transactions** (Bank Transfers), you sacrifice **Analytics** (Reports).
*   If you optimize for **Scale** (Billions of users), you sacrifice **Consistency** (Seeing the latest data instantly).

**The Solution:**
We have different *types* of databases for different jobs. As a Data Engineer, your #1 skill is **choosing the right tool**.

**The Big Three Categories:**
1.  **RDBMS (Relational):** The "Old Reliable". Postgres, MySQL, Oracle. Great for banking, strict rules.
2.  **OLAP (Data Warehousing):** The "Number Cruncher". Snowflake, Redshift. Great for analytics and reporting.
3.  **NoSQL (Non-Relational):** The "Scale Monster". DynamoDB, Cassandra, MongoDB. Great for real-time apps with massive traffic.

---

## Core Concepts in Plain English

**ACID (The Bank's Best Friend):**
*   **A**tomicity: All or nothing. If money leaves Account A but fails to reach Account B, the whole thing rolls back.
*   **C**onsistency: Data never violates rules (e.g., balance cannot be negative).
*   **I**solation: Two people checking the same balance at the exact same millisecond don't confuse the database.
*   **D**urability: Once the screen says "Success", the data is safe even if the datacenter burns down.

**CAP Theorem (The Law of Physics):**
You can only have 2 of these 3:
1.  **C**onsistency: Everyone sees the same data at the same time.
2.  **A**vailability: The system never returns an error.
3.  **P**artition Tolerance: The system works even if the network cable is cut.
*   *RDBMS* chooses CA (Fails if network breaks).
*   *Cassandra* chooses AP (Always works, but data might be old).
*   *HBase* chooses CP (Consistently correct, but might return Errors).

**Normalization vs Denormalization:**
*   **Normalization (SQL):** Don't repeat data. Store "User Address" in one place. Join tables to find it. *Saves space, ensures consistency.*
*   **Denormalization (NoSQL):** Copy data everywhere. Store "User Address" inside the Order, inside the Invoice, inside the User profile. *Uses more space, but reads are instant (No Joins).*

---

## Architecture / Deep Dive

**Row-Oriented (Postgres/MySQL):**
*   Stores data like: `[ID, Name, Age, Salary]`, `[ID, Name, Age, Salary]`.
*   Good for: "Find User 123 and show me everything about them." (CRUD).
*   Bad for: "What is the average Salary?" (Has to read Name and Age just to skip them).

**Column-Oriented (Snowflake/Redshift/Parquet):**
*   Stores data like: `[ID, ID, ID]`, `[Name, Name, Name]`, `[Salary, Salary, Salary]`.
*   Good for: "What is the average Salary?" (Reads ONLY the Salary block. Ignores everything else. 100x faster).
*   Bad for: "Insert a new User." (Has to write to 10 different blocks on disk).

**Key-Value / Wide-Column (DynamoDB/Cassandra):**
*   Stores data like a giant HashMap. `Key: User123 -> Value: {Block of Data}`.
*   Good for: "Get User 123". (O(1) lookup speed. Constant time, no matter how much data).
*   Bad for: "Find all users named Steve". (Has to scan the whole database).

---

## Databases at Capital One

**1. The Transactional Core (Postgres/RDS):**
*   **Data:** Account Balances, User Profiles, Payment Ledgers.
*   **Why:** ACID compliance is non-negotiable. If you send money, it MUST exactly equal the amount subtracted.

**2. The Data Warehouse (Snowflake):**
*   **Data:** 5 years of historical transactions, credit bureau reports, marketing clicks.
*   **Why:** Analysts need to run "SELECT AVG(spend) FROM transactions WHERE state='VA'". Snowflake's column storage crushes this.

**3. The Real-Time Edge (DynamoDB/Cassandra):**
*   **Data:** Mobile App Login Sessions, Fraud Real-Time Signals.
*   **Why:** We need 5ms latency for millions of users. We don't care about "Joining" tables; we just need to get the session token *now*.

---

## Comparison Table

| Feature | RDBMS (Postgres) | OLAP (Snowflake) | NoSQL (DynamoDB) |
| :--- | :--- | :--- | :--- |
| **Primary Use** | App Backend (CRUD) | Analytics / Reporting | High Scale / Real-Time |
| **Storage** | Row-Based | Column-Based | Key-Value / Doc |
| **Scaling** | Vertical (Bigger Machine) | Elastic (Add Nodes) | Horizontal (Infinite) |
| **Schema** | Strict (CREATE TABLE) | Strict-ish | Flexible (Schemaless) |
| **Joins** | **Fast** | **Fast** (Massive scale) | **Impossible** (or slow) |
| **Write Speed** | Moderate | Slow (Batch Load) | **Extreme** |

---

## Visuals

```text
THE STORAGE WARS: ROW vs COLUMN vs KEY-VALUE
╔═══════════════════════════════════════════════════════════════════════╗
║  LOGICAL TABLE                                                        ║
║  ID | Name  | City                                                    ║
║  1  | Alice | NY                                                      ║
║  2  | Bob   | LA                                                      ║
║                                                                       ║
║  ROW STORE (Postgres) - Good for single row fetching                  ║
║  [ 1, Alice, NY ] [ 2, Bob, LA ]                                      ║
║  (Reads whole row at once)                                            ║
║                                                                       ║
║  COLUMN STORE (Snowflake) - Good for "Count City"                     ║
║  [ 1, 2 ]                                                             ║
║  [ Alice, Bob ]                                                       ║
║  [ NY, LA ]  <-- Only reads this block for analytics!                 ║
║                                                                       ║
║  KEY-VALUE (DynamoDB) - Good for specific ID lookups                  ║
║  Hash(1) -> {Name:Alice, City:NY}                                     ║
║  Hash(2) -> {Name:Bob, City:LA}                                       ║
║  (Direct pointer hop. No scanning.)                                   ║
╚═══════════════════════════════════════════════════════════════════════╝
```
