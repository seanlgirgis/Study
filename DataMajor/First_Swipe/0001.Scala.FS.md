Let's go! ðŸš€

---

# Phase 1 â€” Scala Fundamentals

## 1. The Basics â€” `val` vs `var`

In Scala, you declare variables in two ways:

```scala
val name = "John"   // immutable â€” like Python's constants (can't reassign)
var age = 30        // mutable â€” can be reassigned
age = 31            // âœ… fine
name = "Jane"       // âŒ error â€” val cannot be reassigned
```

In data engineering, you'll use `val` almost exclusively. Immutability is a core Scala principle.

---

## 2. Type System

Scala is **statically typed**, but type inference means you rarely need to declare types explicitly:

```scala
val name: String = "John"   // explicit type
val name = "John"           // inferred â€” Scala knows it's a String
val age = 30                // inferred as Int
val salary = 95000.50       // inferred as Double
val isActive = true         // inferred as Boolean
```

---

## 3. Functions

```scala
// Basic function
def greet(name: String): String = {
  "Hello, " + name
}

// Single-line (no braces needed)
def greet(name: String): String = "Hello, " + name

// Calling it
greet("John")   // returns "Hello, John"
```

Compare to Python:
```python
def greet(name: str) -> str:
    return "Hello, " + name
```

Very similar â€” just different syntax.

---

## 4. String Interpolation

```scala
val name = "John"
val age = 30

println(s"My name is $name and I am $age years old")
// "My name is John and I am 30 years old"

// Expression inside string
println(s"Next year I'll be ${age + 1}")
```

The `s` before the string enables interpolation â€” similar to Python's f-strings.

---

## 5. Collections â€” The Big Three

```scala
// List â€” ordered, immutable
val fruits = List("apple", "banana", "cherry")

// Map â€” key-value pairs
val scores = Map("Alice" -> 95, "Bob" -> 87)

// Seq â€” general sequence (List is a Seq)
val nums = Seq(1, 2, 3, 4, 5)
```

---

## Quick Exercise

Before we move on, what do you think this outputs?

```scala
val nums = List(1, 2, 3, 4, 5)
val doubled = nums.map(x => x * 2)
println(doubled)
```

Close, but not quite! The output would be:

```
List(2, 4, 6, 8, 10)
```

The key distinction â€” `map()` on a `List` **returns a List**, not a Map. It transforms each element and keeps the same collection type.

A `Map` in Scala is a key-value structure like `Map("a" -> 1)`. What you described would actually look like this:

```scala
val nums = List(1, 2, 3, 4, 5)
val doubled = nums.map(x => (x, x * 2))  // creates tuples
println(doubled.toMap)
// Output: Map(1 -> 2, 2 -> 4, 3 -> 6, 4 -> 8, 5 -> 10)
```

That's actually a great instinct though â€” you were thinking like a data engineer, turning it into key-value pairs. That pattern comes up a lot!

---

## Higher-Order Functions

This is where Scala gets powerful. These will feel familiar from PySpark.

```scala
val nums = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

// map â€” transform every element
val doubled = nums.map(x => x * 2)
// List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)

// filter â€” keep elements that match condition
val evens = nums.filter(x => x % 2 == 0)
// List(2, 4, 6, 8, 10)

// reduce â€” collapse list into single value
val sum = nums.reduce((a, b) => a + b)
// 55

// chaining â€” this is where it gets elegant
val result = nums
  .filter(x => x % 2 == 0)   // keep evens: 2,4,6,8,10
  .map(x => x * 3)            // multiply by 3: 6,12,18,24,30
  .reduce((a, b) => a + b)    // sum: 90

println(result)  // 90
```

Notice how chaining reads like a pipeline â€” **filter â†’ transform â†’ aggregate**. Sound familiar? That's exactly how PySpark works under the hood.

---

## Shorthand Syntax

Scala lets you shorten lambda expressions using `_` as a placeholder:

```scala
val nums = List(1, 2, 3, 4, 5)

nums.map(x => x * 2)   // full form
nums.map(_ * 2)         // shorthand â€” same result

nums.filter(x => x > 3)  // full form
nums.filter(_ > 3)        // shorthand
```

You'll see `_` everywhere in Scala code, so good to recognize it early.

---

## Quick Exercise

What does this return?

```scala
val words = List("spark", "scala", "kafka", "hadoop", "hive")

val result = words
  .filter(w => w.length > 4)
  .map(w => w.toUpperCase)

println(result)
```

---
