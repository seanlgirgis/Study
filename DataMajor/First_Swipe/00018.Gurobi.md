# Gurobi & Optimization
### The English Version

---

## What is Gurobi and Why Does it Exist?

**The Problem:**
Imagine you are Capital One and you need to assign credit limits to 10 million new customers.
*   You have a limited amount of total capital to lend (Budget Constraint).
*   You have risk rules (no one under 600 FICO gets > $5k).
*   You want to **maximize profit** (Objective Function).

If you try to iterate through every possible combination of credit limits for 10 million people, the universe will end before your code finishes. The number of combinations is effectively infinite.

**The Solution:**
**Gurobi** is a mathematical **Solver**. It uses advanced algorithms (Linear Programming, Mixed Integer Programming) to find the **single best solution** to complex problems with billions of possibilities, and it does it in seconds or minutes.

*   **Data Engineering tools (Spark/Flink)** are for *moving and transforming* data.
*   **Machine Learning (XGBoost)** is for *predicting* what will happen.
*   **optimization (Gurobi)** is for *deciding* what to do to get the best result.

**Analogy:**
*   **Spark:** Organizing a pile of 1,000 maps.
*   **Machine Learning:** Predicting which roads have traffic.
*   **Gurobi (Optimization):** Calculating the fastest route to visit 50 cities (The Traveling Salesman Problem).

---

## Core Concepts in Plain English

**Objective Function** — The goal. A single mathematical formula you want to maximize (Profit) or minimize (Cost, Risk).
> *Example: Maximize (Interest Income - Default Loss)*

**Decision Variables** — The knobs you can turn. The things you get to decide.
> *Example: The credit limit for User A ($5k or $10k?)*

**Constraints** — The rules you cannot break. Physics, budget, or business policy.
> *Example: Total lending cannot exceed $1 Billion. User A limit must be > $0.*

**MIP (Mixed Integer Programming)** — A type of problem where some decisions must be whole numbers (Integers).
> *Example: You cannot install 2.5 ATMs. It must be 2 or 3. This makes the math MUCH harder, and this is where Gurobi destroys open-source competitors.*

**Feasible Region** — The set of all possible solutions that follow the rules. Gurobi hunts through this region to find the "Optimal" point.

**Gap** — The difference between the current best solution found and the theoretical best solution. You assume the answer is "perfect" when the Gap is 0.00%.

---

## Architecture / Deep Dive

Gurobi is not a distributed system like Spark. It is a **Computationally Intensive** engine that typically runs on a **Single Massive Machine** (Vertical Scaling).

**How it works (Simplified):**
1.  **Presolve:** Gurobi looks at your rules and deletes the ones that don't matter (like simplifying fractions). This shrinks the problem size.
2.  **Root Node (Relaxation):** It solves an easier version of the problem (ignoring the "Integer" rule) to get a starting point.
3.  **Branch and Bound:** It creates a "Tree" of possibilities. It explores branches that look promising and "prunes" (cuts off) branches that can't possibly beat the current best score.
    *   *This is the magic.* Instead of checking 1 billion options, it mathematically proves that 999 million of them are trash and only checks the remaining few.
4.  **Cutting Planes:** It adds new temporary rules to slice away bad solutions faster.

**Deployment Architecture:**
Since it's not distributed like Spark, you don't run it on a 100-node cluster. You run it on one **x1.32xlarge** EC2 instance (128 vCPUs, 2TB RAM).

---

## Gurobi at Capital One

Capital One is one of the world's heaviest users of optimization.

**Use Case 1: Credit Line Increases (CLI)**
*   **Scenario:** We have 5 million existing customers. Who gets a limit increase, and how much?
*   **Input:** Risk scores (from ML models), Budget ($200M this month).
*   **Solver:** Gurobi determines exactly who gets what increase to maximize "Net Present Value" (Profit) while keeping "Portfolio Risk" below 4%.

**Use Case 2: Marketing Offers**
*   **Scenario:** We have 5 slots in an email. We have 50 possible offers (Credit Card, Auto Loan, Savings Account, etc.).
*   **Solver:** Which combination of 5 offers gives the highest probability of click conversion?

**Use Case 3: ATM Cash Replenishment**
*   **Scenario:** 2,000 ATMs. Trucks cost money to roll. ATMs running out of cash is bad.
*   **Solver:** What is the optimal route and schedule for trucks to minimize driving costs while ensuring 99.9% cash availability?

---

## Comparison Table

| Feature | Open Source (SciPy / PuLP / CBC) | Commercial (Gurobi / CPLEX) |
| :--- | :--- | :--- |
| **Speed** | Slow. Can take hours for complex MIPs. | **Fast.** Often 10x-100x faster than open source. |
| **Scale** | Chokes on problems > 100k variables. | Handles problems with **Millions** of variables. |
| **Cost** | Free. | **Expensive.** (Thousands per license/core). |
| **Support** | StackOverflow. | Dedicated PhD Enterprise Support. |
| **Usage** | Academic, simple prototypes. | **Fortune 500 Production Systems.** |

---

## Visuals

```text
THE OPTIMIZATION "BLACK BOX"
╔═══════════════════════════════════════════════════════════════════════╗
║  INPUTS                                                               ║
║  ┌───────────────────────────┐       ┌───────────────────────────┐    ║
║  │ DATA (from Database)      │       │ PARAMETERS (Business)     │    ║
║  │ - Customer Risk Score     │       │ - Total Budget            │    ║
║  │ - Current Balance         │       │ - Max Risk Threshold      │    ║
║  └──────────────┬────────────┘       └──────────────┬────────────┘    ║
║                 │                                   │                 ║
║                 ▼                                   ▼                 ║
║  ┌─────────────────────────────────────────────────────────────────┐  ║
║  │  PYTHON MODEL (gurobipy)                                        │  ║
║  │  Defines:                                                       │  ║
║  │  1. Variables (x = limit_increase)                              │  ║
║  │  2. Constraints (sum(x) <= Budget)                              │  ║
║  │  3. Objective (maximize sum(x * profit_margin))                 │  ║
║  └──────────────────────────────┬──────────────────────────────────┘  ║
║                                 │ Passes Model                        ║
║                                 ▼                                     ║
║  ┌─────────────────────────────────────────────────────────────────┐  ║
║  │  GUROBI SOLVER ENGINE (C++ Core)                                │  ║
║  │  [Presolve] → [Branch & Bound] → [Simplex Method]               │  ║
║  │  (Iterates through search tree, pruning bad branches)           │  ║
║  └──────────────────────────────┬──────────────────────────────────┘  ║
║                                 │ Returns Optimal Solution            ║
║                                 ▼                                     ║
║  OUTPUT                                                               ║
║  ┌─────────────────────────────────────────────────────────────────┐  ║
║  │  OPTIMAL PLAN                                                   │  ║
║  │  User A: +$1,000                                                │  ║
║  │  User B: +$0                                                    │  ║
║  │  User C: +$500                                                  │  ║
║  │  Total Profit: $4.2M (The mathematical maximum)                 │  ║
║  └─────────────────────────────────────────────────────────────────┘  ║
╚═══════════════════════════════════════════════════════════════════════╝
```
