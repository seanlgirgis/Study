
# Mock Interview â€” MongoDB & NoSQL

Same rules â€” answer like you're in the room. Model answer and diagrams after each response.

---

## Question 1 â€” Warm Up

**"Can you explain what NoSQL is, why it was created, and how MongoDB specifically differs from a traditional relational database like PostgreSQL or Oracle?"**

# Feedback First

---

## What You Nailed âœ…

**"Big companies got flooded with huge, messy, fast-changing data"** â€” perfect origin story. Concise and accurate.

**Three scaling problems identified** â€” rigid schemas, slow scaling, expensive at scale. All correct.

**Document vs row distinction** â€” cleanly explained. "Each one can have different fields" captures the core flexibility perfectly.

**Schema flexibility tradeoff** â€” correctly identified that relational requires upfront planning while MongoDB allows change. Shows maturity.

**"Many places use both"** â€” this is the senior engineer answer. Knowing that the real world uses polyglot persistence rather than picking one winner signals production experience.

**Best use cases** â€” correctly mapped relational to transactions and accuracy, MongoDB to speed and flexibility.

---

## What to Tighten Up ğŸ”§

**Missing the three V's of big data context** â€” giving the origin story more technical framing elevates it:

*"The NoSQL movement emerged around 2009-2010 driven by the three V's â€” Volume, Velocity, and Variety. Volume because datasets grew from gigabytes to petabytes. Velocity because data needed to be written and read in milliseconds not seconds. Variety because data stopped fitting neatly into rows and columns."*

**Missing BSON** â€” MongoDB specifically uses BSON not plain JSON. One sentence matters:

*"MongoDB stores data as BSON â€” Binary JSON â€” which extends JSON with additional data types like dates, integers, and binary data, and is optimized for fast serialization and deserialization."*

**Missing the join problem specifically** â€” this is the core technical reason NoSQL was needed:

*"The fundamental problem with relational databases at scale was joins. A query joining five tables with billions of rows each requires the database to correlate records across massive datasets â€” it becomes catastrophically slow. MongoDB solves this by embedding related data inside a single document, eliminating the join entirely."*

**Missing horizontal vs vertical scaling distinction** â€” your answer said "harder to add servers" but the technical framing is more precise:

*"Relational databases scale vertically â€” you buy a bigger, more expensive single server. MongoDB scales horizontally through sharding â€” you add more commodity servers and MongoDB distributes data across them automatically. At Capital One scale, horizontal scaling is the only economically viable option."*

---

# Model Answer

---

*"NoSQL stands for Not Only SQL â€” it's a family of database technologies that emerged around 2009 to 2010 to solve problems that relational databases couldn't handle at internet scale.*

**Why NoSQL was created:**

*The trigger was the three V's of big data â€” Volume, Velocity, and Variety. Volume because companies like Google, Amazon, and Facebook were dealing with petabytes of data, far beyond what a single relational database server could hold. Velocity because modern applications need reads and writes in milliseconds â€” a relational database doing complex joins across billion-row tables simply cannot deliver that. Variety because data stopped fitting neatly into rows and columns â€” user profiles, social posts, product catalogs, IoT sensor readings all have irregular, nested, variable structures that a fixed schema handles poorly.*

*Relational databases had three specific architectural limitations at this scale. First, rigid schemas â€” changing a table structure on a billion-row table requires a migration that can lock the table for hours. Second, vertical scaling â€” relational databases scale by buying bigger, more expensive single servers, which has a hard physical and economic ceiling. Third, the join problem â€” reconstructing a customer profile from five normalized tables with billions of rows each requires correlating massive datasets, which becomes catastrophically slow.*

*NoSQL solved all three â€” flexible schemas that change without migrations, horizontal scaling by adding commodity servers, and embedding related data together to eliminate joins.*

**How MongoDB specifically differs from PostgreSQL or Oracle:**

*MongoDB is a document database. Instead of storing data in rows and columns it stores self-contained documents in BSON format â€” Binary JSON â€” which extends standard JSON with additional data types optimized for fast serialization.*

*The fundamental difference is the data model. In PostgreSQL a customer record is spread across multiple normalized tables â€” a customers table, an addresses table, an accounts table, a transactions table â€” and you reconstruct the full customer picture with a multi-table join. In MongoDB that same customer is a single document containing all their information nested together. One read operation retrieves everything. No joins.*

*Schema is the second major difference. PostgreSQL requires you to define every column upfront. Adding a new field means an ALTER TABLE statement that can be expensive at scale. MongoDB has no enforced schema by default â€” you can add new fields to documents at any time without touching existing documents. Capital One would add schema validation rules on top to maintain data quality while keeping the flexibility.*

*Scaling is the third difference. PostgreSQL scales vertically â€” you buy a bigger server. MongoDB scales horizontally through sharding â€” you add more servers and MongoDB automatically distributes your data across them using a shard key. When Capital One's customer database grows from 50 million to 100 million customers, you add shards rather than buying a more expensive machine.*

*The honest answer for a bank like Capital One is that both have a role. Core financial transactions â€” debits, credits, transfers â€” live in relational databases because ACID compliance and complex reporting are non-negotiable there. Customer profiles, fraud case management, enrichment stores for ML models â€” those live in MongoDB because the data is naturally document-shaped and flexibility and read speed matter more than relational integrity."*

---

# Diagrams

```
WHY NOSQL WAS CREATED â€” THE THREE V'S
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                       â•‘
â•‘   VOLUME              VELOCITY             VARIETY                   â•‘
â•‘   â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€                   â•‘
â•‘   Gigabytes           Seconds              Rows & Columns            â•‘
â•‘      â”‚                   â”‚                     â”‚                     â•‘
â•‘      â”‚ grew to           â”‚ needed to be        â”‚ became              â•‘
â•‘      â–¼                   â–¼                     â–¼                     â•‘
â•‘   Petabytes           Milliseconds         Nested JSON               â•‘
â•‘                                            Arrays                    â•‘
â•‘                                            Variable fields           â•‘
â•‘                                            Unstructured text         â•‘
â•‘                                                                       â•‘
â•‘   Relational databases could not handle all three simultaneously     â•‘
â•‘   NoSQL was built specifically for this combination                  â•‘
â•‘                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


RELATIONAL VS MONGODB â€” DATA MODEL
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                       â•‘
â•‘  RELATIONAL (PostgreSQL)          MONGODB                            â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€                            â•‘
â•‘                                                                       â•‘
â•‘  customers table:                 customers collection:              â•‘
â•‘  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”           {                                  â•‘
â•‘  â”‚ id â”‚ name  â”‚ email â”‚             "_id": "C001",                   â•‘
â•‘  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤             "name": "Alice Johnson",         â•‘
â•‘  â”‚C001â”‚ Alice â”‚a@e.comâ”‚             "email": "a@e.com",              â•‘
â•‘  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜             "address": {                     â•‘
â•‘                                       "city": "McLean",              â•‘
â•‘  addresses table:                     "state": "VA"                  â•‘
â•‘  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”            },                               â•‘
â•‘  â”‚ id â”‚  city  â”‚ state â”‚            "accounts": [                    â•‘
â•‘  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤              {"type": "checking",           â•‘
â•‘  â”‚C001â”‚ McLean â”‚  VA   â”‚               "balance": 5420.00},          â•‘
â•‘  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜              {"type": "savings",            â•‘
â•‘                                        "balance": 28750.00}          â•‘
â•‘  accounts table:                    ],                               â•‘
â•‘  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         "risk_score": 0.12,             â•‘
â•‘  â”‚ id â”‚   type   â”‚ balance â”‚         "is_premium": true              â•‘
â•‘  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       }                                 â•‘
â•‘  â”‚C001â”‚ checking â”‚ 5420.00 â”‚                                         â•‘
â•‘  â”‚C001â”‚ savings  â”‚28750.00 â”‚       ONE document                      â•‘
â•‘  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       ONE read                          â•‘
â•‘                                    NO joins                          â•‘
â•‘  THREE tables                                                        â•‘
â•‘  ONE join query                                                      â•‘
â•‘  Gets slower as tables grow                                          â•‘
â•‘                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


SCALING â€” VERTICAL VS HORIZONTAL
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                       â•‘
â•‘  RELATIONAL â€” VERTICAL SCALING         MONGODB â€” HORIZONTAL SCALING  â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â•‘
â•‘                                                                       â•‘
â•‘        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘        â”‚ BIGGEST â”‚                    â”‚Shard 1â”‚â”‚Shard 2â”‚â”‚Shard 3â”‚   â•‘
â•‘        â”‚ SERVER  â”‚                    â”‚C001-  â”‚â”‚C334K- â”‚â”‚C667K- â”‚   â•‘
â•‘        â”‚ MONEY   â”‚                    â”‚C333K  â”‚â”‚C666K  â”‚â”‚C999K  â”‚   â•‘
â•‘        â”‚ CAN BUY â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â–²        â–²        â–²      â•‘
â•‘             â–²                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â•‘
â•‘             â”‚                                       â”‚               â•‘
â•‘        Hit ceiling                          mongos router           â•‘
â•‘        Buy even bigger                      directs queries         â•‘
â•‘        server ğŸ’¸                            to right shard          â•‘
â•‘                                                                      â•‘
â•‘        Hard physical limit                 Add shards = add scale   â•‘
â•‘        Expensive                           Commodity servers        â•‘
â•‘        Single point of failure             Fault tolerant           â•‘
â•‘                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


TERM MAPPING â€” RELATIONAL TO MONGODB
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                       â•‘
â•‘   RELATIONAL          MONGODB              NOTES                     â•‘
â•‘   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€                     â•‘
â•‘   Database      â•â•â–º   Database             Same concept              â•‘
â•‘   Table         â•â•â–º   Collection           No fixed schema           â•‘
â•‘   Row           â•â•â–º   Document             JSON/BSON format          â•‘
â•‘   Column        â•â•â–º   Field                Varies per document       â•‘
â•‘   Primary Key   â•â•â–º   _id                  Auto-generated if needed  â•‘
â•‘   Foreign Key   â•â•â–º   Reference/Embed      Design choice             â•‘
â•‘   JOIN          â•â•â–º   $lookup / Embed      Embed = no join needed    â•‘
â•‘   INDEX         â•â•â–º   Index                Same concept              â•‘
â•‘   VIEW          â•â•â–º   View                 Same concept              â•‘
â•‘   SQL           â•â•â–º   MQL                  MongoDB Query Language    â•‘
â•‘   ACID Txn      â•â•â–º   Multi-doc Txn        Added in MongoDB 4.0      â•‘
â•‘                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


WHEN TO USE WHICH AT CAPITAL ONE
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                       â•‘
â•‘   USE RELATIONAL (PostgreSQL/Oracle) WHEN:                           â•‘
â•‘   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â•‘
â•‘   âœ… Core financial transactions â€” debits, credits, transfers        â•‘
â•‘   âœ… Regulatory reporting requiring complex joins                    â•‘
â•‘   âœ… ACID compliance across multiple entities is non-negotiable      â•‘
â•‘   âœ… Data is highly structured and consistent                        â•‘
â•‘                                                                       â•‘
â•‘   USE MONGODB WHEN:                                                   â•‘
â•‘   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â•‘
â•‘   âœ… Customer 360 profiles â€” nested, variable attributes             â•‘
â•‘   âœ… Fraud case management â€” each case has different evidence        â•‘
â•‘   âœ… ML feature store â€” hundreds of behavioral features per customer â•‘
â•‘   âœ… Transaction enrichment â€” fast lookup during real-time pipeline  â•‘
â•‘   âœ… Product catalogs â€” different fields per product type            â•‘
â•‘                                                                       â•‘
â•‘   CAPITAL ONE LIKELY USES BOTH â€” polyglot persistence                â•‘
â•‘   Right database for the right job                                   â•‘
â•‘                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---
---
---

## Question 2 â€” Stepping Up

**"Walk me through MongoDB's architecture â€” replica sets, sharding, and the WiredTiger storage engine. How do these components work together to give you both high availability and horizontal scale?"**

