# Mock Interview â€” Gurobi & Optimization

Same rules â€” answer in the room, model answer and diagrams after each response.

---

## Question 1 â€” Warming Up (The "What is it?" Check)

**"I see Gurobi on your resume alongside Spark and Machine Learning. Can you explain to me what Gurobi actually *does*? How is it different from a Machine Learning model?"**

# Feedback First

## What You Nailed âœ…
*   **Decision vs Prediction:** Correctly identified that ML *predicts* the future (e.g., who will default), while Optimization *decides* what to do (e.g., who gets a loan).
*   **The "Solver" Concept:** Correctly described Gurobi as a mathematical engine that finds the *best* answer, not just a *good* answer.
*   **Objective Function:** Mentioned "Maximizing Profit" or "Minimizing Cost" as the goal.

## What to Tighten Up ğŸ”§
*   *Deterministic Nature:* You need to emphasize that Gurobi is deterministic. If you run the same problem twice, you get the exact same answer. ML is probabilistic.
*   *Constraints:* You missed the key concept of "Constraints." Optimization is about finding the best answer *within the rules*. Without rules, the answer is usually "give everyone infinite money."
*   *Feasible Region:* A good keyword to drop. "Gurobi searches the feasible region defined by our business rules."

# Model Answer

---

"The simplest way to distinguish them is: **Machine Learning predicts the future; Optimization (Gurobi) decides how to act on it.**

**Machine Learning (XGBoost/TensorFlow):**
Propensity Modeling. It tells us: *'User A has a 12% chance of defaulting if we give them a $5k line.'* It outputs probabilities.

**Optimization (Gurobi):**
Decision Making. It takes those probabilities as input, looks at our total budget of $100M, our risk policies (max 4% portfolio default rate), and mathematically solves the puzzle: *'Which specific 50,000 users should get loans, and for how much, to maximize total profit while staying under the risk cap?'*

Gurobi solves for the **Objective Function** (Max Profit) subject to **Constraints** (Budget, Risk, Fairness). It finds the mathematically optimal set of decisions out of billions of possibilities."

# Diagrams

```text
PREDICTION vs. DECISION
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  Step 1: MACHINE LEARNING (The Forecast)                              â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â•‘
â•‘  â”‚ HISTORICAL    â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚ ML MODEL           â”‚                       â•‘
â•‘  â”‚ DATA          â”‚       â”‚ (XGBoost)          â”‚                       â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â•‘
â•‘                                    â”‚ Outputs Probabilities            â•‘
â•‘                                    â–¼                                  â•‘
â•‘                          "User A Risk: 2%"                            â•‘
â•‘                          "User B Risk: 15%"                           â•‘
â•‘                                    â”‚                                  â•‘
â•‘  ==================================â”‚================================  â•‘
â•‘                                    â”‚                                  â•‘
â•‘  Step 2: OPTIMIZATION (The Decision - Gurobi)                         â•‘
â•‘                                    â”‚                                  â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â•‘
â•‘  â”‚ CONSTRAINTS   â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚ GUROBI SOLVER      â”‚â—„â”€â”€â”€â”€â”€â”‚ OBJECTIVE   â”‚  â•‘
â•‘  â”‚ "Max Risk 5%" â”‚       â”‚ (The Engine)       â”‚      â”‚ "Max $$"    â”‚  â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â•‘
â•‘                                    â”‚ Outputs Decisions                â•‘
â•‘                                    â–¼                                  â•‘
â•‘                          "User A: Approve $5k"                        â•‘
â•‘                          "User B: Reject"                             â•‘
â•‘                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## Question 2 â€” Data Engineer Level (Architecture)

**"Gurobi is computationally intensive. How do you design a pipeline to run a Gurobi optimization for 10 million customers? Do you run it inside Spark executors?"**

# Feedback First

## What You Nailed âœ…
*   **Vertical Scaling:** Correctly identified that Optimization problems (specifically MIPs) are hard to parallelize. You generally need one massive machine, not a cluster of small ones.
*   **The "Extract-Solve-Load" Patter:** You correctly described pulling data out of the lake, solving it, and putting it back.

## What to Tighten Up ğŸ”§
*   *Don't run Gurobi ON Spark:* You hinted at running Gurobi *inside* Spark mapPartitions. For a single global optimization (like "Global Budget Allocation"), this is impossible because the variables are interdependent. You can't split the problem.
*   *Memory Bound:* Mention that these problems are memory hogs. You need an **x1e.32xlarge** (High Memory) EC2 instance.
*   *Partitioning Strategy:* If the problem *can* be split (e.g., optimize each Store independently), *then* you can use Spark. But for a "Portfolio Level" optimization, it must be a single massive job.

# Model Answer

---

"It depends entirely on whether the problem is **Separable** or **Global**.

**Scenario A: Global Constraint (The Capital One Case)**
If we have a *single* budget of $100M that applies across all 10 million customers, we **cannot** run this on Spark executors. The decision for Customer A affects the remaining budget for Customer Z. All variables are coupled.

*   **Architecture:** We use an **Extract-Solve-Load** pattern.
    1.  **Spark:** Aggregates the 10M records and calculates the coefficients (profit margins, risk).
    2.  **Write:** Spark writes a constrained input file (or Parquet) to S3.
    3.  **Solver Node:** We spin up a single massive EC2 instance (e.g., `x1.32xlarge` with 2TB RAM). It downloads the data, builds the matrix, and solves.
    4.  **Load:** The Solver writes the optimal decision vector (User ID, Credit Limit) back to S3.

**Scenario B: Local Constraints (The Walmart Case)**
If we are optimizing inventory for 5,000 stores, and Store A's inventory does not affect Store B, then the problem is **Separable**.
*   **Architecture:** We run Gurobi **inside** Spark.
    *   `df.repartition("store_id").mapPartitions(optimize_store)`
    *   Spark spins up 5,000 tasks, each solving a small Gurobi model in parallel."

# Diagrams

```text
GLOBAL VS. LOCAL OPTIMIZATION PIPELINES
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  SCENARIO A: GLOBAL (One giant budget)                                â•‘
â•‘  [Spark Cluster] â”€â”€extractâ”€â”€â–º [S3] â”€â”€loadâ”€â”€â–º [SINGLE GIANT EC2]       â•‘
â•‘  (Pre-process)                (Data)         (Gurobi solves 10M vars) â•‘
â•‘                                                                       â•‘
â•‘  -------------------------------------------------------------------  â•‘
â•‘                                                                       â•‘
â•‘  SCENARIO B: LOCAL (5,000 independent stores)                         â•‘
â•‘  [Spark Driver]                                                       â•‘
â•‘       â”‚                                                               â•‘
â•‘       â”œâ”€â”€â–º [Executor 1] â”€â”€ runs Gurobi (Store 1..100)                 â•‘
â•‘       â”œâ”€â”€â–º [Executor 2] â”€â”€ runs Gurobi (Store 101..200)               â•‘
â•‘       â””â”€â”€â–º [Executor 3] â”€â”€ runs Gurobi (Store 201..300)               â•‘
â•‘                                                                       â•‘
â•‘  (Massively Parallel Optimization)                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## Question 3 â€” Lead Level (The "Gap")

**"We have a massive optimization run that takes 12 hours, but we need the results in 2 hours. The Business Team is complaining. What do you do?"**

# Feedback First

## What You Nailed âœ…
*   **Time Limit:** You mentioned setting a `TimeLimit` parameter. Simple but correct.
*   **Hardware:** "Get a bigger box." Valid, but expensive and maybe not enough.

## What to Tighten Up ğŸ”§
*   *The MIP Gap:* This is the professional answer. You rarely need the "Perfect" solution. You need a "Good Enough" solution.
*   *Relaxation:* Tuning the `MIPGap` parameter is crucial.
    *   *"Stopping at a 0.01% gap (Proven Optimal) might take 10 hours."*
    *   *"Stopping at a 1% gap (Good Enough) might take 10 minutes."*
*   *Warm Start:* If you solved yesterday's problem, feed that solution as a starting point for today. The solver will converge much faster because it starts with a valid solution.

# Model Answer

---

"I would approach this in three stages: **Relaxation, Warm Starting, and Tuning.**

**1. The MIP Gap Trade-off (The big win):**
In optimization, the last 1% of improvement usually takes 90% of the time. Proving a solution is *mathematically perfect* (0.00% Gap) is expensive.
I would meet with the business and ask: *'If I can give you a solution within 2 hours that is guaranteed to be within 1% of the perfect answer, is that acceptable?'*
Usually, a 1% profit loss is worth the 10-hour speedup. We simply set `model.Params.MIPGap = 0.01`.

**2. Warm Starting:**
Business data doesn't change drastically day-to-day. I would take *yesterday's* optimal solution and feed it into today's run as a **MIP Start**. This gives Gurobi a valid "incumbent" solution immediately, allowing it to prune the search tree much more aggressively.

**3. Model Simplification:**
Are we optimizing tens of thousands of variables that have negligible impact? I would analyze the **Dual Values** (Shadow Prices) to see which constraints are actually binding. We might be able to aggregate the 'long tail' of small customers into a single bucket, reducing the problem dimensions significantly."

# Diagrams

```text
THE MIP GAP (TIME VS QUALITY)
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                       â•‘
â•‘  Objective Value ($)                                                  â•‘
â•‘  â–²                                                                    â•‘
â•‘  â”‚                                                                    â•‘
â•‘  â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PROVEN OPTIMAL        â•‘
â•‘  â”‚                        â”‚                     (High CPU cost)       â•‘
â•‘  â”‚                 _______â–¼_________                                  â•‘
â•‘  â”‚       _________/                 \                                 â•‘
â•‘  â”‚      /                            \_________                       â•‘
â•‘  â”‚     /  <-- Solution Quality (Best Found)    \_________             â•‘
â•‘  â”‚    /                                                  \________    â•‘
â•‘  â”‚   /                                                            \   â•‘
â•‘  â”‚  |                                                                 â•‘
â•‘  â”‚  | <--- Upper Bound (Theoretical Best Possible)                    â•‘
â•‘  â”‚  |                                                                 â•‘
â•‘  â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â•‘
â•‘     Time                                                              â•‘
â•‘                                                                       â•‘
â•‘     [10 Min]           [2 Hours]                 [12 Hours]           â•‘
â•‘     Gap: 5%            Gap: 1%                   Gap: 0.00%           â•‘
â•‘     "Okay"             "Good Enough"             "Perfect"            â•‘
â•‘                                                                       â•‘
â•‘  Strategy: Stop HERE (2 Hours). Don't pay for the last 1%.            â•‘
â•‘                                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```
